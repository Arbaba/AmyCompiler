package amyc
package codegen

import analyzer._
import ast.Identifier
import ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, _}
import utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

	val seq = (a: Code, b: Code) => a <:> b
    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
			def loadOperands(lhs: Expr, rhs: Expr): Code = cgExpr(lhs) <:> cgExpr(rhs)
			/*def equalsPattern(pattern: Pattern): Code = pattern match {
				case WildcardPattern() => Const(1)
				case LiteralPattern(lit) => cgExpr(lit) <:> Eq
				case IdPattern(_) => Const(1)
				case CaseClassPattern(b, args) => GetGlobal()
			}*/
			/*def matchAndBind(scrut: Int, pattern: Pattern): (Code, Map[Identifier, Int]) = {
				pattern match {
					case WildcardPattern() => (Const(1), Map())
					case IdPattern(x) =>
						val binded = lh.getFreshLocal
						(GetLocal(scrut) <:>
						SetLocal(binded) <:>
						Const(1), Map(x -> binded)) //+ bind
					case LiteralPattern(lit) =>
						(GetLocal(scrut) <:>
						//Const(lit) <:>
						Eq, Map())
					case CaseClassPattern(caseClass, fields) =>
						val atScrut = lh.getFreshLocal
						GetLocal(scrut) <:> //@scrutinee
						Load <:>
						Const((table getConstructor caseClass).get.index) <:>
						Eq <:>
						fields.map{
							case field =>
								val vi = lh.getFreshLocal

								matchAndBind(scrut, field)
						}.reduceLeft(seq)
				}
			}*/
			def matchAndBind(matchCases: List[MatchCase], scrut: Int): Code = {
				matchCases match {
					case MatchCase(pattern, ex) :: otherCases => pattern match {
						case WildcardPattern() => cgExpr(ex)
						case LiteralPattern(lit) =>
							GetLocal(scrut) <:>
							cgExpr(lit) <:>
							Eq <:>
							If_i32 <:>
							cgExpr(ex) <:>
							Else <:>
							matchAndBind(otherCases, scrut) <:>
							End
						case IdPattern(x) =>
							val i = lh.getFreshLocal
							GetLocal(scrut) <:>
							SetLocal(i) <:>
							cgExpr(ex)(locals + (x -> i), lh)
						case CaseClassPattern(cons, args) =>
							//C1 == C2
							val allAnd: (Int) => Code = (i) => i2c(And)
							GetGlobal(scrut) <:>
							Const((table getConstructor cons).get.index) <:>
							Eq <:>
								(args.zip(0 until args.size).map {
									case (arg, i) =>
										val vi = lh.getFreshLocal
										GetGlobal(scrut) <:>
										adtField(i) <:>
										Load <:>
										//cgExpr(arg) <:>
										Eq
								} reduceLeft seq) <:>
								(0 until args.size).map(allAnd).reduceLeft(seq) <:>
								If_i32 <:>
								cgExpr(ex) <:>
							//args map matchAndBind
							Else <:>
							matchAndBind(otherCases, scrut) <:>
							End
							/*patterns map {
								case x: Pattern =>
							}*/

					}
					case Nil => Unreachable
				}
			}
			expr match {
				case Variable(n) => GetLocal(locals(n))
				case IntLiteral(i) => Const(i)
				case BooleanLiteral(b) => Const(if(b) 1 else 0)
				case StringLiteral(s) => mkString(s)
				case UnitLiteral() => Const(0)
				case Plus(lhs, rhs) => loadOperands(lhs, rhs) <:> Add
				case Minus(lhs, rhs) => loadOperands(lhs, rhs) <:> Sub
				case Times(lhs, rhs) => loadOperands(lhs, rhs) <:> Mul
				case AmyDiv(lhs, rhs) => loadOperands(lhs, rhs) <:> Div
				case Mod(lhs, rhs) => loadOperands(lhs, rhs) <:> Rem
				case LessThan(lhs, rhs) =>
					loadOperands(lhs, rhs) <:>
					Lt_s
				case LessEquals(lhs, rhs) => loadOperands(lhs, rhs) <:> Le_s
				case AmyAnd(lhs, rhs) => loadOperands(lhs, rhs) <:> And
				case AmyOr(lhs, rhs) => loadOperands(lhs, rhs) <:> Or
				case Equals(lhs, rhs) => loadOperands(lhs, rhs) <:> Eq
				case Concat(lhs, rhs) =>
					loadOperands(lhs, rhs) <:>
					Call("String_concat")
				case Not(e) => cgExpr(e) <:> If_i32 <:> Const(0) <:> Else <:> Const(1) <:> End
				case Neg(e) =>
					Const(0) <:>
					cgExpr(e) <:>
					Sub
				case Ite(i, t, e) =>
					cgExpr(i) <:>
					If_i32 <:>
					cgExpr(t) <:>
					Else <:>
					cgExpr(e) <:>
					End
				case AmyCall(qname, args) =>
					val func = program.modules.filter { case mod: ModuleDef => mod.defs.map(_.name).exists(id => id.toString == qname.name.toString) }
					(table getConstructor qname, table getFunction qname) match {
						case (Some(ConstrSig(argTypes, _, idx)), _) =>
							def cgAdt(ref: Int): Code = {
								if(args.isEmpty) {
 								 GetLocal(ref)// Leave @ref on stack
 							 }
 							 else {
								 val argsCode = args map cgExpr zip (0 until args.size)
								 //val stackNStore: (Code, Int) => Code = (code: Code, i: Int) =>
								 val stackCode: List[Code] = argsCode map { case (code, i) => code <:> GetLocal(ref) <:> adtField(i) <:> Store }
								 (stackCode reduceLeft seq) <:>
 								 GetLocal(ref)
 							 }
							}
							val ref = lh.getFreshLocal
							GetGlobal(memoryBoundary) <:>
							SetLocal(ref) <:>// ref = memoryBoundary
							GetGlobal(memoryBoundary) <:>
							Const(args.size + 1) <:>
							Add <:>
							SetGlobal(memoryBoundary) <:> // Add size of ADT to memoryBoundary
							Const(idx) <:>
							GetLocal(ref) <:>
							Store <:> // Store constructor @ ref
							cgAdt(ref)
							if(!args.isEmpty) {
								SetLocal(idx) <:>
								(args map cgExpr reduceLeft seq)
							}
							else {
								GetGlobal(memoryBoundary) <:>
								SetLocal(idx)
							}
						case (_, Some(_)) =>
							(args map cgExpr reduceLeft seq) <:>
							Call(func(0).name.toString + "_" + qname.name)
					}
				case Let(ParamDef(name, tt), v, bdy) =>
					val i = lh.getFreshLocal
					cgExpr(v) <:>
					SetLocal(i) <:>
					cgExpr(bdy)(locals + (name -> i), lh)
				case Error(err) => mkString("Error:	") <:> cgExpr(err) <:> Call("Std_printString") <:> Unreachable
				case Match(scrut, cases) =>
					val scruti = lh.getFreshLocal()
					cgExpr(scrut) <:>
					SetLocal(scruti) <:> // @scrut
					matchAndBind(cases, scruti)
				case Sequence(e1, e2) => cgExpr(e1) <:> cgExpr(e2)
			}
    }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
