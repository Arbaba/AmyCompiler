package amyc
package codegen

import analyzer._
import ast.{Identifier, SymbolicTreeModule}
import ast.SymbolicTreeModule.{And => AmyAnd, Call => AmyCall, Div => AmyDiv, Or => AmyOr, _}
import utils.{Context, Pipeline}
import Utils.fullName
import wasm.{Instructions, _}
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
		import ctx.reporter._
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      	defs.collect {
					case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) => cgFunction(fd, name, false)
					case od: OpDef => cgOperator(od)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

		// Generate code for an operator
    def cgOperator(od: OpDef): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module
			println(s"define ${od.name}")
      Function(od.name.name, od.params.size, false){ lh =>
        val locals = od.paramNames.zipWithIndex.toMap
        cgExpr(od.body)(locals, lh)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
			println(s"define $name")
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }
		/*for {
			module.defs
			op	<- List("+", "-", "*")
		} cgFunction(op)*/

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Instructions.Code =
      expr match {
      case IntLiteral(lit) =>
        i2c(Const(lit))
      case StringLiteral(str)=>
        mkString(str)
      case UnitLiteral() =>
        i2c(Const(0))
      case BooleanLiteral(bool) =>
        if(true) Const(1) else Const(0)
      case Variable(name) =>
        GetLocal(locals(name))
      //Arith Operators
      case  Plus(lhs: Expr, rhs: Expr)   =>
        cgExpr(lhs).<:>(cgExpr(rhs)).<:>(Add)
      case  Minus(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs).<:>(cgExpr(rhs)).<:>(Sub)
      case  Times(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs).<:>(cgExpr(rhs)).<:>(Mul)
      case  SymbolicTreeModule.Div(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs).<:>(cgExpr(rhs)).<:>(Div)
      case  Mod(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs).<:>(cgExpr(rhs)).<:>(Rem)
      //Boolean Operators
      case  LessThan(lhs: Expr, rhs: Expr)  =>
        cgExpr(lhs).<:>(cgExpr(rhs)).<:>(Lt_s)

      case  LessEquals(lhs: Expr, rhs: Expr)  =>
        cgExpr(lhs).<:>(cgExpr(rhs)).<:>(Le_s)

      case  SymbolicTreeModule.And(lhs: Expr, rhs: Expr) =>
        //cgExpr(lhs).<:>(cgExpr(rhs)).<:>(And)
        //ShortCircuit
        cgExpr(lhs) <:> If_i32 <:> cgExpr(rhs) <:> Else <:> Const(0) <:> End
      case  SymbolicTreeModule.Or(lhs: Expr, rhs: Expr) =>
        //cgExpr(lhs).<:>(cgExpr(rhs)).<:>(Or)
        cgExpr(lhs) <:> If_i32 <:> Const(1) <:>  Else <:> cgExpr(rhs) <:> End

      case  Equals(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs).<:>(cgExpr(rhs)).<:>(Eq)

      //String concatenation
      case  Concat(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs) <:>
        cgExpr(rhs) <:>
        Call(concatImpl.name)


      //Unary Operators
      case Not(e) =>
        Const(0) <:> cgExpr(e) <:> Sub
      case Neg(e) =>
        cgExpr(e) <:>
        Eqz

      //Rest
      case SymbolicTreeModule.Call(qname, args) =>
        table.getFunction(qname) match {
          case Some(FunSig(argTypes, retType, owner)) =>
            val argsToStack = for (arg <- args) yield cgExpr(arg)
            argsToStack <:> Call(fullName(owner, qname))
          case None =>
            table.getConstructor(qname) match {
              case Some(ConstrSig(argTypes, parent, index)) =>
                val oldMemBoundary = lh.getFreshLocal()
                val padding = argTypes.size * 4 + 1
                val storeArgs: List[Code] = for ((arg, index) <- args.zipWithIndex) yield {
                  GetLocal(oldMemBoundary) <:> Const(index * 4 + 1) <:> Add <:> cgExpr(arg) <:> Store
                }

                val setMemory = {
                  GetGlobal(memoryBoundary) <:>
                    SetLocal(oldMemBoundary) <:>
                    GetGlobal(memoryBoundary) <:>
                    Const(padding) <:>
                    Add <:>
                    SetGlobal(memoryBoundary)
                }

                val setIndex = {
                  GetLocal(oldMemBoundary) <:>
                    Const(index) <:>
                    Add <:>
                    Store
                }
                setMemory <:> setIndex <:> storeArgs
              case None =>
								table.getOperator(qname.name) match {
									case Some((id, OpSig(argTypes, retType, _))) =>
										val argsToStack = for (arg <- args) yield cgExpr(arg)
										argsToStack <:> Call(id.name)
									case None => fatal("Error @ codegen")
								}
            }
        }
case Sequence(e1, e2) =>
        cgExpr(e1) <:> Drop <:> cgExpr(e2)

case Let(ParamDef(name, TypeTree(typee)), value, body) =>
	val i = lh.getFreshLocal()
	 cgExpr(value) <:> SetLocal(i)  <:> cgExpr(body)(locals + (name -> i),lh)
case Ite(cond, thenn, elze) =>
	 cgExpr(cond) <:>
	 If_i32 <:>
	 cgExpr(thenn) <:>
	 Else <:>
	 cgExpr(elze) <:>
	 End


case Error(msg) =>
// fatal(msg, msg.position)
        cgExpr(msg) <:> Call("Std_printString") <:> Instructions.Unreachable

}

Module(
program.modules.last.name.name,
defaultImports,
globalsNo,
wasmFunctions ++ (program.modules flatMap cgModule)
)

}
}
