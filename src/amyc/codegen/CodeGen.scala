package amyc
package codegen

import analyzer._
import ast.{Identifier, SymbolicTreeModule}
import ast.SymbolicTreeModule.{And => AmyAnd, Call => AmyCall, Div => AmyDiv, Or => AmyOr, _}
import utils.{Context, Pipeline}
import Utils.fullName
import wasm.{Instructions, _}
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }


    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Instructions.Code =
      expr match {
      case IntLiteral(lit) =>
        i2c(Const(lit))
      case StringLiteral(str)=>
        mkString(str)
      case UnitLiteral() =>
        i2c(Const(0))
      case BooleanLiteral(bool) =>
        if(true) Const(1) else Const(0)
      case Variable(name) =>
        GetLocal(locals(name))
      //Arith Operators
      case  Plus(lhs: Expr, rhs: Expr)   =>
        cgExpr(lhs).<:>(cgExpr(rhs)).<:>(Add)
      case  Minus(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs).<:>(cgExpr(rhs)).<:>(Sub)
      case  Times(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs).<:>(cgExpr(rhs)).<:>(Mul)
      case  SymbolicTreeModule.Div(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs).<:>(cgExpr(rhs)).<:>(Div)
      case  Mod(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs).<:>(cgExpr(rhs)).<:>(Rem)
      //Boolean Operators
      case  LessThan(lhs: Expr, rhs: Expr)  =>
        cgExpr(lhs).<:>(cgExpr(rhs)).<:>(Lt_s)

      case  LessEquals(lhs: Expr, rhs: Expr)  =>
        cgExpr(lhs).<:>(cgExpr(rhs)).<:>(Le_s)

      case  SymbolicTreeModule.And(lhs: Expr, rhs: Expr) =>
        //cgExpr(lhs).<:>(cgExpr(rhs)).<:>(And)
        //ShortCircuit
        cgExpr(lhs) <:> If_i32 <:> cgExpr(rhs) <:> Else <:> Const(0) <:> End
      case  SymbolicTreeModule.Or(lhs: Expr, rhs: Expr) =>
        //cgExpr(lhs).<:>(cgExpr(rhs)).<:>(Or)
        cgExpr(lhs) <:> If_i32 <:> Const(1) <:>  Else <:> cgExpr(rhs) <:> End

      case  Equals(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs).<:>(cgExpr(rhs)).<:>(Eq)

      //String concatenation
      case  Concat(lhs: Expr, rhs: Expr) =>
        cgExpr(lhs) <:>
        cgExpr(rhs) <:>
        Call(concatImpl.name)


      //Unary Operators
      case Not(e) =>
        Const(0) <:> cgExpr(e) <:> Sub
      case Neg(e) =>
        cgExpr(e) <:>
        Eqz

      //Rest
      case SymbolicTreeModule.Call(qname, args) =>
        table.getFunction(qname) match {
          case Some(FunSig(argTypes, retType, owner)) =>
            val argsToStack = for (arg <- args) yield cgExpr(arg)
            argsToStack <:> Call(fullName(owner, qname))
          case None =>
            table.getConstructor(qname) match {
              case Some(ConstrSig(argTypes, parent, index)) =>
                val oldMemBoundary = lh.getFreshLocal()
                val padding = argTypes.size * 4 + 1
                val storeArgs: List[Code] = for ((arg, index) <- args.zipWithIndex) yield {
                  GetLocal(oldMemBoundary) <:> Const(index * 4 + 1) <:> Add <:> cgExpr(arg) <:> Store
                }

                val setMemory = {
                  GetGlobal(memoryBoundary) <:>
                    SetLocal(oldMemBoundary) <:>
                    GetGlobal(memoryBoundary) <:>
                    Const(padding) <:>
                    Add <:>
                    SetGlobal(memoryBoundary)
                }

                val setIndex = {
                  GetLocal(oldMemBoundary) <:>
                    Const(index) <:>
                    Add <:>
                    Store
                }
                setMemory <:> setIndex <:> storeArgs
              case None =>
                //fatal(s"The table doesn't contain a constructor for $qname", expr.position)
                Code(Nil)
            }
        }
case Sequence(e1, e2) =>
        cgExpr(e1) <:> Drop <:> cgExpr(e2)

case Let(ParamDef(name, TypeTree(typee)), value, body) =>
val i = lh.getFreshLocal()
 cgExpr(value) <:> SetLocal(i)  <:> cgExpr(body)(locals + (name -> i),lh)
case Ite(cond, thenn, elze) =>
 cgExpr(cond) <:>
 If_i32 <:>
 cgExpr(thenn) <:>
 Else <:>
 cgExpr(elze) <:>
 End


case Error(msg) =>
// fatal(msg, msg.position)
        cgExpr(msg) <:> Call("Std_printString") <:> Instructions.Unreachable
case Match(scrut, cases) =>
// Returns additional constraints from within the pattern with all bindings
// from identifiers to types for names bound in the pattern.
// (This is analogous to `transformPattern` in NameAnalyzer.)
  def matchAndBind(scrutCode :Code, casee: Pattern): (Code, Map[Identifier, Int]) = casee match {
    case WildcardPattern() => (Const(1), Map.empty)
    case LiteralPattern(lit) => (scrutCode <:> cgExpr(lit) <:> Eq, Map.empty)
    case IdPattern(id) =>
      val localVar = lh.getFreshLocal()
      val comparison = scrutCode <:> SetLocal(localVar) <:>  Const(1)
      (comparison, locals + (id -> localVar))
    case CaseClassPattern(qname, args) =>
      val allocateScrut = lh.getFreshLocal()
      val writeScrut = scrutCode <:> SetLocal(allocateScrut) <:> GetLocal(allocateScrut) <:> Load

      val Some(ConstrSig(argsTypes, parent, identifier)) = table.getConstructor(qname)

      val compareIds = Const(identifier) <:> Eq
      //We call match and bind on each argument
      val compareArgs : List[(Code, Map[Identifier, Int]) ]= {
        for( (arg, index) <- args.zipWithIndex) yield{
          matchAndBind(GetLocal(allocateScrut) <:> Utils.adtField(index) <:> Load, arg)
        }
     }

      val matchConditions = compareArgs.map(x => x._1)
      val argsWithChainedConditional = {
        matchConditions match {
          case Nil => Nil
          case x :: Nil => List(x)
          case x :: y :: z => (x <:> y <:> And) ::  z.map(x => x <:> And)
        }
      }
      val bindings = if(!compareArgs.isEmpty){ compareArgs.map(_._2).reduce{(x,y ) => x ++ y}} else Map.empty[Identifier, Int]
      (writeScrut <:> compareIds <:> If_i32 <:> argsWithChainedConditional <:> Else <:> Const(0) <:> End, bindings)
  }

  val matches : List[(Code, Code)] = cases.map{case MatchCase(pat, ex)=> {
        val (code, bindings) = matchAndBind(cgExpr(scrut), pat)
      (code, cgExpr(ex)(bindings ++ locals,lh))

      }
  }
  //We write the conditions to return the correct match body. We use shortCircuit as well
  val matchesWithCondition : List[Code]= matches.map{case(cond, expr) => cond <:> If_i32 <:> expr <:> Else }  ::: i2c(Const(0))  :: matches.map(x => i2c(End))
  matchesWithCondition.reduce(_<:>_)

}

Module(
program.modules.last.name.name,
defaultImports,
globalsNo,
wasmFunctions ++ (program.modules flatMap cgModule)
)

}
}
